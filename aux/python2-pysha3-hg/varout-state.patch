--- a/Modules/_sha3/sha3module.c	Wed Jul 31 13:33:01 2013 +0200
+++ b/Modules/_sha3/sha3module.c	Tue Sep 10 23:14:04 2013 -0400
@@ -267,15 +267,27 @@
     SHA3_state temp;
     HashReturn res;
 
-    ENTER_HASHLIB(self);
-    SHA3_copystate(temp, self->hash_state);
-    LEAVE_HASHLIB(self);
     if (self->hashbitlen) {
+        ENTER_HASHLIB(self);
+        SHA3_copystate(temp, self->hash_state);
+        LEAVE_HASHLIB(self);
         res = SHA3_done(&temp, digest);
+        SHA3_clearstate(temp);
     } else {
-       res = SHA3_squeeze(&temp, digest, self->digestlen * 8);
+#ifdef WITH_THREAD
+        if(self->lock){
+            Py_BEGIN_ALLOW_THREADS
+            PyThread_acquire_lock(self->lock, 1);
+            res = SHA3_squeeze(&self->hash_state, digest, self->digestlen * 8);
+            PyThread_release_lock(self->lock);
+            Py_END_ALLOW_THREADS
+        } else {
+            res = SHA3_squeeze(&self->hash_state, digest, self->digestlen * 8);
+        }
+#else
+        res = SHA3_squeeze(&self->hash_state, digest, self->digestlen * 8);
+#endif
     }
-    SHA3_clearstate(temp);
     if (res != SUCCESS) {
         PyErr_SetString(PyExc_RuntimeError, "internal error in SHA3 Final()");
         return NULL;
@@ -362,15 +374,27 @@
     HashReturn res;
 
     /* Get the raw (binary) digest value */
-    ENTER_HASHLIB(self);
-    SHA3_copystate(temp, self->hash_state);
-    LEAVE_HASHLIB(self);
     if (self->hashbitlen) {
+        ENTER_HASHLIB(self);
+        SHA3_copystate(temp, self->hash_state);
+        LEAVE_HASHLIB(self);
         res = SHA3_done(&temp, digest);
+        SHA3_clearstate(temp);
     } else {
-       res = SHA3_squeeze(&temp, digest, self->digestlen * 8);
+#ifdef WITH_THREAD
+        if(self->lock){
+            Py_BEGIN_ALLOW_THREADS
+            PyThread_acquire_lock(self->lock, 1);
+            res = SHA3_squeeze(&self->hash_state, digest, self->digestlen * 8);
+            PyThread_release_lock(self->lock);
+            Py_END_ALLOW_THREADS
+        } else {
+            res = SHA3_squeeze(&self->hash_state, digest, self->digestlen * 8);
+        }
+#else
+        res = SHA3_squeeze(&self->hash_state, digest, self->digestlen * 8);
+#endif
     }
-    SHA3_clearstate(temp);
     if (res != SUCCESS) {
         PyErr_SetString(PyExc_RuntimeError, "internal error in SHA3 Final()");
         return NULL;
@@ -407,11 +431,27 @@
     }
 
     /* Get the raw (binary) digest value */
-    ENTER_HASHLIB(self);
-    SHA3_copystate(temp, self->hash_state);
-    LEAVE_HASHLIB(self);
-    res = SHA3_squeeze(&temp, digest, digestlen * 8);
-    SHA3_clearstate(temp);
+    if(self->hashbitlen){
+        ENTER_HASHLIB(self);
+        SHA3_copystate(temp, self->hash_state);
+        LEAVE_HASHLIB(self);
+        res = SHA3_squeeze(&temp, digest, digestlen * 8);
+        SHA3_clearstate(temp);
+    }else{
+#ifdef WITH_THREAD
+        if(self->lock){
+            Py_BEGIN_ALLOW_THREADS
+            PyThread_acquire_lock(self->lock, 1);
+            res = SHA3_squeeze(&self->hash_state, digest, digestlen * 8);
+            PyThread_release_lock(self->lock);
+            Py_END_ALLOW_THREADS
+        } else {
+            res = SHA3_squeeze(&self->hash_state, digest, digestlen * 8);
+        }
+#else
+        res = SHA3_squeeze(&self->hash_state, digest, digestlen * 8);
+#endif
+    }
     if (res != SUCCESS) {
         PyErr_SetString(PyExc_RuntimeError, "internal error in SHA3 Squeeze()");
         PyMem_Free(digest);
@@ -576,12 +616,42 @@
 #endif
 }
 
+static PyObject *
+SHA3_get_state(SHA3object *self, void *closure)
+{
+    return PyBytes_FromStringAndSize((const char *)&self->hash_state,
+                                     sizeof(SHA3_state));
+}
+
+static int
+SHA3_set_state(SHA3object *self, PyObject *value, void *closure)
+{
+    if (value == NULL) {
+        PyErr_SetString(PyExc_TypeError, "State cannot be deleted");
+        return -1;
+    }
+
+    if (! PyBytes_CheckExact(value)) {
+        PyErr_SetString(PyExc_TypeError, "Attribute state must be a bytes");
+        return -1;
+    }
+
+    if (PyBytes_Size(value) != sizeof(SHA3_state)) {
+        PyErr_Format(PyExc_ValueError, "Attribute state must be a bytes of length %d", sizeof(SHA3_state));
+        return -1;
+    }
+
+    memcpy(&self->hash_state, PyBytes_AsString(value), sizeof(SHA3_state));
+    return 0;
+}
+
 static PyGetSetDef SHA3_getseters[] = {
     {"block_size", (getter)SHA3_get_block_size, NULL, NULL, NULL},
     {"name", (getter)SHA3_get_name, NULL, NULL, NULL},
     {"digest_size", (getter)SHA3_get_digest_size, NULL, NULL, NULL},
     {"_capacity_bits", (getter)SHA3_get_capacity_bits, NULL, NULL, NULL},
     {"_rate_bits", (getter)SHA3_get_rate_bits, NULL, NULL, NULL},
+    {"state", (getter)SHA3_get_state, (setter)SHA3_set_state, NULL, NULL},
     {NULL}  /* Sentinel */
 };
 
